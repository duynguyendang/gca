{"nodes":[{"id":"design_agent/state.py","name":"state.py","language":"python","group":"python","code":"from typing import TypedDict, List, Dict, Any, Optional\nfrom enum import Enum\nimport os\nfrom datetime import datetime\n\nclass WorkflowStatus(Enum):\n    INITIALIZED = \"initialized\"\n    PLANNING = \"planning\"\n    IN_PROGRESS = \"in_progress\"\n    PAUSED = \"paused\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\nclass WorkflowState(TypedDict):\n    \"\"\"Workflow state with project folder support\"\"\"\n    project_folder: str  # Base folder for project-specific files\n    \"\"\"Represents the state of the workflow graph.\"\"\"\n    groups: List[Dict[str, Any]] # Configuration for all groups and their steps\n    steps: List[Dict[str, Any]] # Flat list of all steps for easy lookup by index\n    current_group_index: Optional[int] # Index of the currently selected group\n    current_step_in_group_index: Optional[int] # Index of the current step within the selected group\n    outputs: Dict[str, str]           # Accumulated outputs {step_name: output_file_path}\n    user_choice: str                  # Raw input from the user ('exit', group number, or invalid)\n    error: Optional[str]              # Error message from the last executed step\n    run_mode: Optional[str]           # Mode for running steps ('continue_group' or None)\n    status: WorkflowStatus            # Current status of the workflow\n    last_updated: str                 # Timestamp of the last state update (ISO 8601)\n\nclass WorkflowStateManager:\n    def __init__(self, state: Optional[WorkflowState] = None):\n        if state:\n            self._state = state\n        else:\n            self._state = self._initialize_new_state()\n\n    def _initialize_new_state(self) -\u003e WorkflowState:\n        return WorkflowState(\n            project_folder=\"\",\n            groups=[],\n            steps=[],\n            current_group_index=None,\n            current_step_in_group_index=None,\n            outputs={},\n            user_choice=\"\",\n            error=None,\n            run_mode=None,\n            status=WorkflowStatus.INITIALIZED,\n            last_updated=datetime.now().isoformat()\n        )\n\n    def get_state(self) -\u003e WorkflowState:\n        return self._state\n\n    def update_state(self, new_data: Dict[str, Any]):\n        # Validate transitions here if needed\n        for key, value in new_data.items():\n            if key in self._state:\n                self._state[key] = value\n        self._state['last_updated'] = datetime.now().isoformat()\n\n    def transition_status(self, new_status: WorkflowStatus):\n        if not self._validate_transition(self._state['status'], new_status):\n            raise ValueError(f\"Invalid state transition from {self._state['status']} to {new_status}\")\n        self._state['status'] = new_status\n        self._state['last_updated'] = datetime.now().isoformat()\n\n    def _validate_transition(self, current_status: WorkflowStatus, new_status: WorkflowStatus) -\u003e bool:\n        # Define valid state transitions\n        valid_transitions = {\n            WorkflowStatus.INITIALIZED: {WorkflowStatus.PLANNING, WorkflowStatus.FAILED},\n            WorkflowStatus.PLANNING: {WorkflowStatus.IN_PROGRESS, WorkflowStatus.FAILED},\n            WorkflowStatus.IN_PROGRESS: {WorkflowStatus.PAUSED, WorkflowStatus.COMPLETED, WorkflowStatus.FAILED},\n            WorkflowStatus.PAUSED: {WorkflowStatus.IN_PROGRESS, WorkflowStatus.COMPLETED, WorkflowStatus.FAILED},\n            WorkflowStatus.COMPLETED: {WorkflowStatus.INITIALIZED}, # Allow reset for new workflow\n            WorkflowStatus.FAILED: {WorkflowStatus.INITIALIZED} # Allow reset after failure\n        }\n        return new_status in valid_transitions.get(current_status, set())\n\n    def save_state(self, file_path: str):\n        # This is a placeholder. In a real scenario, you'd use a proper serialization library (e.g., json, pickle)\n        # and handle file I/O errors.\n        import json\n        with open(file_path, 'w') as f:\n            # Convert Enum to its value for JSON serialization\n            serializable_state = self._state.copy()\n            serializable_state['status'] = serializable_state['status'].value\n            json.dump(serializable_state, f, indent=4)\n\n    @classmethod\n    def load_state(cls, file_path: str) -\u003e Optional['WorkflowStateManager']:\n        import json\n        if not os.path.exists(file_path):\n            return None\n        with open(file_path, 'r') as f:\n            loaded_data = json.load(f)\n            # Convert status string back to Enum\n            loaded_data['status'] = WorkflowStatus(loaded_data['status'])\n            return cls(state=loaded_data)"},{"id":"design_agent/state.py:WorkflowStatus","name":"state.py:WorkflowStatus","kind":"class","language":"python","group":"python","code":"class WorkflowStatus(Enum):\n    INITIALIZED = \"initialized\"\n    PLANNING = \"planning\"\n    IN_PROGRESS = \"in_progress\"\n    PAUSED = \"paused\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\""}],"links":[{"source":"design_agent/state.py","target":"design_agent/state.py:WorkflowStatus","relation":"defines"},{"source":"design_agent/state.py","target":"design_agent/state.py:WorkflowStatus","relation":"defines"},{"source":"design_agent/state.py","target":"design_agent/state.py:WorkflowStatus","relation":"defines"}]}