{"nodes":[{"id":"analysis/rectify.go","name":"rectify.go","language":"go","group":"go","code":"package analysis\n\nimport \"github.com/google/mangle/ast\"\n\n// RectifyAtom ensures all arguments of an atom are variables.\n// It returns a tuple (rectified atom, extra terms, fresh variables, defined variables).\n//\n// An atom p(t_1, ..., t_n) is rectified if each t_i is a variable and all are distinct.\n//\n// We go a bit further and also ensure that t_i are distinct from a set variables that\n// may have been defined previously (\"used\"). On the other hand, we do not generate fresh\n// variables for wildcards \"_\".\n// If the given atom is already rectified in\n// this stronger sense, than extra terms and fresh variables will be empty and boundVars\n// contains atom arguments in left-to-right order.\nfunc RectifyAtom(atom ast.Atom, usedVars VarList) (ast.Atom, []ast.Term, []ast.Variable, []ast.Variable) {\n\tused := usedVars.AsMap()\n\tpred := atom.Predicate\n\tnewArgs := make([]ast.BaseTerm, pred.Arity)\n\n\tvar freshVars, boundVars []ast.Variable\n\tvar fml []ast.Term\n\tmakeFresh := func(i int, arg ast.BaseTerm) {\n\t\tfresh := ast.FreshVariable(used)\n\t\tfreshVars = append(freshVars, fresh)\n\t\tnewArgs[i] = fresh\n\t\tfml = append(fml, ast.Eq{fresh, arg})\n\t}\n\tfor i, arg := range atom.Args {\n\t\tswitch a := arg.(type) {\n\t\tcase ast.ApplyFn:\n\t\t\tmakeFresh(i, arg)\n\n\t\tcase ast.Constant:\n\t\t\tmakeFresh(i, arg)\n\n\t\tcase ast.Variable:\n\t\t\tif a.Symbol == \"_\" {\n\t\t\t\tnewArgs[i] = a\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := used[a]; ok {\n\t\t\t\tmakeFresh(i, arg)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tused[a] = true\n\t\t\tnewArgs[i] = a\n\t\t\tboundVars = append(boundVars, a)\n\t\t}\n\t}\n\treturn ast.Atom{pred, newArgs}, fml, freshVars, boundVars\n}\n"},{"id":"analysis/rectify.go:RectifyAtom","name":"rectify.go:RectifyAtom","kind":"function","language":"go","group":"go","code":"func RectifyAtom(atom ast.Atom, usedVars VarList) (ast.Atom, []ast.Term, []ast.Variable, []ast.Variable) {\n\tused := usedVars.AsMap()\n\tpred := atom.Predicate\n\tnewArgs := make([]ast.BaseTerm, pred.Arity)\n\n\tvar freshVars, boundVars []ast.Variable\n\tvar fml []ast.Term\n\tmakeFresh := func(i int, arg ast.BaseTerm) {\n\t\tfresh := ast.FreshVariable(used)\n\t\tfreshVars = append(freshVars, fresh)\n\t\tnewArgs[i] = fresh\n\t\tfml = append(fml, ast.Eq{fresh, arg})\n\t}\n\tfor i, arg := range atom.Args {\n\t\tswitch a := arg.(type) {\n\t\tcase ast.ApplyFn:\n\t\t\tmakeFresh(i, arg)\n\n\t\tcase ast.Constant:\n\t\t\tmakeFresh(i, arg)\n\n\t\tcase ast.Variable:\n\t\t\tif a.Symbol == \"_\" {\n\t\t\t\tnewArgs[i] = a\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := used[a]; ok {\n\t\t\t\tmakeFresh(i, arg)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tused[a] = true\n\t\t\tnewArgs[i] = a\n\t\t\tboundVars = append(boundVars, a)\n\t\t}\n\t}\n\treturn ast.Atom{pred, newArgs}, fml, freshVars, boundVars\n}"},{"id":"github.com/google/mangle/ast","name":"ast","group":"unknown"},{"id":"usedVars.AsMap","name":"usedVars.AsMap","group":"unknown"},{"id":"ast.FreshVariable","name":"ast.FreshVariable","group":"unknown"},{"id":"makeFresh","name":"makeFresh","group":"unknown"}],"links":[{"source":"analysis/rectify.go","target":"analysis/rectify.go:RectifyAtom","relation":"defines"},{"source":"analysis/rectify.go","target":"github.com/google/mangle/ast","relation":"imports"},{"source":"analysis/rectify.go:RectifyAtom","target":"usedVars.AsMap","relation":"calls"},{"source":"analysis/rectify.go:RectifyAtom","target":"ast.FreshVariable","relation":"calls"},{"source":"analysis/rectify.go:RectifyAtom","target":"makeFresh","relation":"calls"}]}